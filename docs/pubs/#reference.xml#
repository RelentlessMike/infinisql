<?xml version="1.0" encoding="utf-8"?>
<book xmlns="http://docbook.org/ns/docbook"
xmlns:xi="http://www.w3.org/2001/XInclude"
xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">

<title><trademark>InfiniSQL</trademark> Reference Manual</title>
<info><pubdate><?dbtimestamp format="Y-m-d H:M:S"?></pubdate>
<productname>InfiniSQL</productname><productnumber>0.1.2-alpha</productnumber></info>
<preface>
<title>Preface</title>
<para>
This is the reference manual for InfiniSQL. It describes configuration
settings and user capabilities such as SQL support, schema and user management,
and using the API for creating stored procedures.
It is based on the 0.1.2-alpha release, available on <link xl:href="http://github.com/infinisql/infinisql.git">GitHub</link>.
</para>
</preface>

<part>
<title><trademark>InfiniSQL</trademark> Configuration Reference Manual</title>
<partintro>
<para>
These entries describe all available configuration options for InfiniSQL as
well as the format of the config file.
</para>
</partintro>

<chapter>
<title>Configuration File Format and Parameters</title>
<refentry xml:id="configfile">
<refmeta>
  <refentrytitle>Configuration File</refentrytitle>
</refmeta>
<refnamediv>
  <refname>Configuration File</refname>
  <refpurpose>The structure and contents of the InfiniSQL configuration file.</refpurpose>
</refnamediv>
<refsect1>
  <title>Description of Configuration File</title>
<para>
InfiniSQL has only one configuration file, <filename>etc/infinisqlmgr.conf</filename>, and
it is read once upon startup. It is planned
in the near future to be a dynamically configurable system. But for the time being,
there is a single config file. It is read upon startup by
<command>infinisqlmgr/infinisqlmgr.py</command>, which uses Python's <link xl:href="http://docs.python.org/2/library/configparser.html">ConfigParser</link> module to process configuration
parameters. There is a sample configuration file shipped with the source called
<filename>etc/infinisqlmgr.conf-sample</filename>. This file contains all
necessary parameters to start up a single process InfiniSQL database.
  General configuration syntax, such as parameter assignments and commenting,
should be pretty self-explanatory. But they are explained in detail in the
ConfigParser documentation. All parameters are required. Some may have blank
values, but each parameter must be defined in the config file for InfiniSQL to
start correctly.
</para>
<para>
<bridgehead>
The following sections are defined in the config file:
</bridgehead>
</para>
<itemizedlist>
<listitem><para>[DEFAULT]</para>
<para>
This section contains parameters which pertain to other sections.
If a parameter does not appear explicitly in a particular section, but does appear
in [DEFAULT], then the parameter is still accessible from that section. This section
is described as part of Python's ConfigParser documentation.
</para></listitem>
<listitem><para>[global]</para>
<para>
  This section contains parameters that apply to all nodes within an InfiniSQL cluster.
</para>
</listitem>
<listitem><para>[node_[0-9]+]</para>
<para>
  Each <command>infinisqld</command> process within a cluster is defined within these
sections. InfiniSQL defines a node as a running <command>infinisqld</command> process--
any number of nodes may execute within a single host operating system instance. Likewise,
any number of hosts may have <command>infinisqld</command> node processes running upon
them.
Each node has a nodeid, which is defined by the numerals following the
underscore in the section definition. All nodes must have unique nodeid's, and they
should start with 1 and increase in single unit increments, such as [node_1], [node_2],
etc. Parameters which are unique to the node, such as <varname>member</varname>,
must be defined in the node's own section.
</para>
</listitem>
</itemizedlist>
<para>
  <bridgehead>Format Strings</bridgehead>
ConfigParser allows definition of format strings (which behave a lot like variables,
or symbol definitions). <filename>etc/infinisqlmgr.conf-sample</filename> includes
two such items, <varname>DEPLOYMENT_DIRECTORY</varname> and <varname>IPADDR</varname>.
<varname>DEPLOYMENT_DIRECTORY</varname> refers to the directory root into which
InfiniSQL has been installed. <varname>IPADDR</varname> refers to an IPV4 address.
These values are interpreted by ConfigParser, and not used by
<command>infinisqlmgr.py</command>. So you are free to use any format string
you want, if any, and to discard those used in the sample. The ConfigParser
documentation describes how format strings are interpolated.
</para>
</refsect1>
</refentry>

<refentry xml:id="username">
<refmeta>
  <refentrytitle>username</refentrytitle>
</refmeta>
<refnamediv>
  <refname>username</refname>
  <refpurpose>user as which <command>infinisqld</command> runs.</refpurpose>
</refnamediv>
<refsect1>
  <title>username</title>
<para>
This is the system userid as which <command>infinisqld</command> runs.
</para>
<example>
<title>username configuration</title>
  <para><varname>username</varname>: infinisql</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="sshkey">
<refmeta>
  <refentrytitle>sshkey</refentrytitle>
</refmeta>
<refnamediv>
  <refname>sshkey</refname>
  <refpurpose>ssh rsa (or dsa) key filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>sshkey</title>
<para>
This is the filename of the ssh private key used to log in to each host upon which
<command>infinisqld</command> node processes are to execute. This key should be
passphrase-less so that it does not require manual intervention after executing
<command>infinisqlmgr.py</command>. This key pair needs to be present in this
location only on the host from which <command>infinisqlmgr.py</command> is executed.
The public portion of the key needs to be in <filename>.ssh/authorized_keys</filename>
on each host running <command>infinisqld</command>.
</para>
<example>
<title>sshkey configuration</title>
  <para><varname>sshkey</varname>: /home/infinisql/.ssh/id_rsa</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ssh">
<refmeta>
  <refentrytitle>ssh</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ssh</refname>
  <refpurpose>ssh client filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>ssh</title>
<para>
This is the location of the ssh client on the system running <command>infinisqlmgr.py</command>.
Obviously, an <command>sshd</command> process needs to be running on each host.
</para>
<example>
<title>ssh configuration</title>
  <para><varname>ssh</varname>: /usr/bin/ssh</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="infinisql">
<refmeta>
  <refentrytitle>infinisqld</refentrytitle>
</refmeta>
<refnamediv>
  <refname>infinisqld</refname>
  <refpurpose>infinisqld filename.</refpurpose>
</refnamediv>
<refsect1>
  <title>infinisqld</title>
<para>
This is the location of the <command>infinisqld</command> executable on the target host.
The InfiniSQL build process places <command>infinisqld</command> within the
<filename>sbin</filename> directory wherein InfiniSQL is installed.
</para>
<example>
<title>infinisqld configuration</title>
<para><varname>infinisqld</varname>: /home/infinisql/infinisql_built/sbin/infinisqld</para>
</example>
<example>
<title>infinisqld configuration with format string interpolation</title>
  <para><varname>infinisqld</varname>: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="logfile">
<refmeta>
  <refentrytitle>logfile</refentrytitle>
</refmeta>
<refnamediv>
  <refname>logfile</refname>
  <refpurpose>infinisqld logfile.</refpurpose>
</refnamediv>
<refsect1>
  <title>logfile</title>
<para>
This is where error and information log messages are written by each infinisqld
process. Actually, there are three files. The two additional files are logfile with
extension .out and .err for stdout and stderr streams from the process, respectively.
Obviously, this is something which needs to be cleaned up as development progresses--but
this is how to find informational messages from running <command>infinisqld</command>
processes on each host. Multiple nodes running on a particular host should each have
a <varname>logfile</varname> entry defined to distinguish messages from each particular
process. The InfiniSQL build process creates a <filename>var</filename> directory upon
installation. This is intended to contain the <filename>logfile</filename>s, but
they can be written anywhere for which <varname>username</varname> has write permission.
</para>
<example>
<title>logfile configuration</title>
<para><varname>logfile</varname>: /home/infinisql/infinisql_built/var/infinisqld.log</para>
</example>
<example>
<title>logfile configuration with format string interpolation</title>
  <para><varname>infinisqld</varname>: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld.log</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="globaladminpassword">
<refmeta>
  <refentrytitle>globaladminpassword</refentrytitle>
</refmeta>
<refnamediv>
  <refname>globaladminpassword</refname>
  <refpurpose>administrative password</refpurpose>
</refnamediv>
<refsect1>
  <title>globaladminpassword</title>
<para>
This is the password for the <varname>admin</varname> user in the
<varname>_global</varname> domain. This is the administrative user for the entire
cluster, and is the only user that exists after the cluster is started. Therefore,
all administrative activities are made possible through this user.
</para>
<example>
<title>globaladminpassword configuration</title>
  <para><varname>globaladminpassword</varname>: passw0rd</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="cfghostport">
<refmeta>
  <refentrytitle>cfghostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>cfghostport</refname>
  <refpurpose>IP:port to listen for configuration commands</refpurpose>
</refnamediv>
<refsect1>
  <title>cfghostport</title>
<para>
This is the IP:tcp port pair upon which <command>infinisqld</command> listens
for configuration commands coming from <command>infinisqlmgr.py</command>. The
IP portion must be numeric dotted-quad IPv4, or <varname>*</varname> (to listen
on all interfaces), and cannot be a host or other name. It must be reachable by
<command>infinisqlmgr.py</command>.
</para>
<example>
<title>cfghostport configuration</title>
  <para><varname>cfghostport</varname>: *:11520</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="cfgremotehostport">
<refmeta>
  <refentrytitle>cfgremotehostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>cfgremotehostport</refname>
  <refpurpose>destination IP:port for configuration commands</refpurpose>
</refnamediv>
<refsect1>
  <title>cfgremotehostport</title>
<para>
The is the IP:tcp port pair by which <command>infinisqlmgr.py</command> reaches
this <command>infinisqld</command> process to send it configuration commands.
It corresponds to the <varname>cfghost</varname> parameter. Having distinct
configuration parameters allows, for instance, clusters to be managed through
network address translation, but it does add a bit of configuration complexity.
Obviously, <command>infinisqlmgr.py</command> must be able to reach.
</para>
<example>
<title>cfgremotehostport configuration</title>
  <para><varname>cfgremotehostport</varname>: 10.101.2.1:11520</para>
</example>
<example>
<title>cfgremotehostport configuration with interpolation</title>
  <para><varname>cfgremotehostport</varname>: %(IPADDR)s:11520</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="mgmthost">
<refmeta>
  <refentrytitle>mgmthost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>mgmthost</refname>
  <refpurpose>hostname for <command>infinisqld</command> node</refpurpose>
</refnamediv>
<refsect1>
  <title>mgmthost</title>
<para>
The hostname passed to <command>ssh</command> to log into to launch
<command>infinisqld</command>. If this entry is blank, then
<command>infinisqlmgr.py</command> will launch <command>infinisql</command>
directly on the existing host.
</para>
<example>
<title>mgmthost configuration</title>
  <para><varname>mgmthost</varname>: node1.infinisql.org</para>
</example>
<example>
<title>mgmthost configuration with interpolation</title>
  <para><varname>mgmthost</varname>: %(IPADDR)s</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="listenhost">
<refmeta>
  <refentrytitle>listenhost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>listenhost</refname>
  <refpurpose>address to listen on for raw configuration</refpurpose>
</refnamediv>
<refsect1>
  <title>listenhost</title>
<para>
IPv4 address or hostname for <command>infinisqld</command> to service
configuration commands from clients.
This is used for user account and schema manipulation. This interface will
likely be deprecated in the near future. An '*' means to listen on all interfaces.
</para>
<example>
<title>listenhost configuration</title>
  <para><varname>listenhost</varname>: *</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="listenport">
<refmeta>
  <refentrytitle>listenport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>listenport</refname>
  <refpurpose>TCP port to listen on for raw configuration</refpurpose>
</refnamediv>
<refsect1>
  <title>listenport</title>
<para>
TCP port <command>infinisqld</command> to service
configuration commands from clients. Corresponds to <varname>listenhost</varname>.
</para>
<example>
<title>listenport configuration</title>
  <para><varname>listenport</varname>: 11521</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ibgatewayhostport">
<refmeta>
  <refentrytitle>ibgatewayhostport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ibgatewayhostport</refname>
  <refpurpose>IP:port pair for inter-node cluster communication</refpurpose>
</refnamediv>
<refsect1>
  <title>ibgatewayhostport</title>
<para>
Other nodes in the cluster communicate to this <command>infinisqld</command> node
via this IP:port. If there are multiple
<varname>ibgateway</varname>s, then those after the first instance are assigned ports
in units ascending. So make sure that there are plenty of ports available to listen
upon directly above this value.
</para>
<example>
<title>ibgatewayhostport configuration</title>
  <para><varname>ibgatewayhostport</varname>: 10.10.10.5:11530</para>
</example>
<example>
<title>ibgatewayhostport configuration with interpolation</title>
  <para><varname>mgmthost</varname>: %(IPADDR)s:11530</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="pghost">
<refmeta>
  <refentrytitle>pghost</refentrytitle>
</refmeta>
<refnamediv>
  <refname>pghost</refname>
  <refpurpose>host for SQL communication</refpurpose>
</refnamediv>
<refsect1>
  <title>pghost</title>
<para>
Clients connect to this hostname or address, or * for all interfaces on the host.
<command>infinisqld</command> uses the <link xl:href="http://www.postgresql.org/docs/devel/static/protocol.html">PostgreSQL Frontend/Backend Protocol</link> on this interface.
</para>
<example>
<title>pghost configuration</title>
  <para><varname>pghost</varname>: *</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="pgport">
<refmeta>
  <refentrytitle>pgport</refentrytitle>
</refmeta>
<refnamediv>
  <refname>pgport</refname>
  <refpurpose>TCP port for SQL communication</refpurpose>
</refnamediv>
<refsect1>
  <title>pgport</title>
<para>
Clients connect to this TCP port, which corresponds to <varname>pghost</varname>.
</para>
<example>
<title>pgport configuration</title>
  <para><varname>pgport</varname>: 15432</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="transactionagents">
<refmeta>
  <refentrytitle>transactionagents</refentrytitle>
</refmeta>
<refnamediv>
  <refname>transactionagents</refname>
  <refpurpose>number of Transaction Agents</refpurpose>
</refnamediv>
<refsect1>
  <title>transactionagents</title>
<para>
The number of Transaction Agent actor threads to create for this node.
</para>
<example>
<title>transactionagents configuration</title>
  <para><varname>transactionagents</varname>: 8</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="engines">
<refmeta>
  <refentrytitle>engines</refentrytitle>
</refmeta>
<refnamediv>
  <refname>engines</refname>
  <refpurpose>number of Engines</refpurpose>
</refnamediv>
<refsect1>
  <title>engines</title>
<para>
The number of Engine actor threads to create for this node.
</para>
<example>
<title>engine configuration</title>
  <para><varname>engine</varname>: 4</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ibgateways">
<refmeta>
  <refentrytitle>ibgateways</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ibgateways</refname>
  <refpurpose>number of Inbound Gateways</refpurpose>
</refnamediv>
<refsect1>
  <title>ibgateways</title>
<para>
The number of Inbound Gateway actor threads to create for this node.
</para>
<example>
<title>ibgateway configuration</title>
  <para><varname>ibgateway</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="obgateways">
<refmeta>
  <refentrytitle>obgateways</refentrytitle>
</refmeta>
<refnamediv>
  <refname>obgateways</refname>
  <refpurpose>number of Outbound Gateways</refpurpose>
</refnamediv>
<refsect1>
  <title>obgateways</title>
<para>
The number of Outbound Gateway actor threads to create for this node.
</para>
<example>
<title>obgateway configuration</title>
  <para><varname>obgateway</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="anonymousping">
<refmeta>
  <refentrytitle>anonymousping</refentrytitle>
</refmeta>
<refnamediv>
  <refname>anonymousping</refname>
  <refpurpose>allow anonymous ping or not</refpurpose>
</refnamediv>
<refsect1>
  <title>anonymousping</title>
<para>
Whether to allow non logged-in users to send an InfiniSQL ping command through the
raw interface.
</para>
<example>
<title>anonymousping configuration</title>
  <para><varname>anonymousping</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="badloginmessages">
<refmeta>
  <refentrytitle>badloginmessages</refentrytitle>
</refmeta>
<refnamediv>
  <refname>badloginmessages</refname>
  <refpurpose>send bad login response messages or not</refpurpose>
</refnamediv>
<refsect1>
  <title>badloginmessages</title>
<para>
Whether to send replies to failed logins through the
raw interface.
</para>
<example>
<title>badloginmessages configuration</title>
  <para><varname>badloginmessages</varname>: 1</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="replica">
<refmeta>
  <refentrytitle>replica</refentrytitle>
</refmeta>
<refnamediv>
  <refname>replica</refname>
  <refpurpose>replica number of which this node is a member</refpurpose>
</refnamediv>
<refsect1>
  <title>replica</title>
<para>
The replica number, starting with 0, to which the node belongs. Currently, only
replica 0 is available. This parameter must be set to 0.
</para>
<example>
<title>replica configuration</title>
  <para><varname>replica</varname>: 0</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="member">
<refmeta>
  <refentrytitle>member</refentrytitle>
</refmeta>
<refnamediv>
  <refname>member</refname>
  <refpurpose>index in replica to which this node belongs</refpurpose>
</refnamediv>
<refsect1>
  <title>member</title>
<para>
Each replica has one or more member nodes. This parameter defines the member number
for the particular node, starting at member 0. All member numbers must be
contiguous whole numbers in a replica. Each node must have a unique member number.
</para>
<example>
<title>member configuration for the 8th node in a replica</title>
  <para><varname>member</varname>: 7</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="userschemamgrnode">
<refmeta>
  <refentrytitle>userschemamgrnode</refentrytitle>
</refmeta>
<refnamediv>
  <refname>userschemamgrnode</refname>
  <refpurpose>node on which the User Schema Manager actor thread runs</refpurpose>
</refnamediv>
<refsect1>
  <title>userschemamgrnode</title>
<para>
This parameter must be only in the [global] section. It defines the node upon
which the User Schema Manager actor runs. There can only be one User Schema Manager
per replica.
</para>
<example>
<title>userschemamgrnode</title>
  <para><varname>userschemamgrnode</varname>: 2</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="deadlockmgrnode">
<refmeta>
  <refentrytitle>deadlockmgrnode</refentrytitle>
</refmeta>
<refnamediv>
  <refname>deadlockmgrnode</refname>
  <refpurpose>node on which the Deadlock Manager actor thread runs</refpurpose>
</refnamediv>
<refsect1>
  <title>deadlockmgrnode</title>
<para>
This parameter must be only in the [global] section. It defines the node upon
which the Deadlock Manager actor runs. There can only be one Deadlock Manager
per replica.
</para>
<example>
<title>deadlockmgrnode</title>
  <para><varname>deadlockmgrnode</varname>: 2</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="activereplica">
<refmeta>
  <refentrytitle>activereplica</refentrytitle>
</refmeta>
<refnamediv>
  <refname>activereplica</refname>
  <refpurpose>the replica that supports client interaction</refpurpose>
</refnamediv>
<refsect1>
  <title>activereplica</title>
<para>
This parameter must be only in the [global] section. It defines the replica
which is the master for all data, to which other replicas are replicated. Currently,
only a single replica is functional, defined as replica 0. This value must be 0.
</para>
<example>
<title>activereplica</title>
  <para><varname>activereplica</varname>: 0</para>
</example>
</refsect1>
</refentry>

</chapter>

<article>
  <title>infinisqlmgr.conf Examples</title>
<section><title>infinisqlmgr.conf Examples</title>

<example>
  <title>Single Node, infinisqlmgr.py on same host as <command>infinisqld</command> node</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost:
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=127.0.0.1
replica: 0
member: 0
</programlisting>
</example>

<example>
  <title>Single Node, infinisqlmgr.py on separate host from <command>infinisqld</command> node</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost: %(IPADDR)s
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=10.102.2.1
replica: 0
member: 0
</programlisting>
</example>

<example>
<title>Eight Nodes, infinisqlmgr.py on separate host from <command>infinisqld</command></title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost: %(IPADDR)s
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
IPADDR=10.102.2.1
replica: 0
member: 0

[node_2]
IPADDR=10.102.2.2
replica: 0
member: 1

[node_3]
IPADDR=10.102.2.3
replica: 0
member: 2

[node_4]
IPADDR=10.102.2.4
replica: 0
member: 3

[node_5]
IPADDR=10.102.2.5
replica: 0
member: 4

[node_6]
IPADDR=10.102.2.6
replica: 0
member: 5

[node_7]
IPADDR=10.102.2.7
replica: 0
member: 6

[node_8]
IPADDR=10.102.2.8
replica: 0
member: 70
</programlisting>
</example>

<example>
<title>Two Nodes, each running on same host with infinisqlmgr.py</title>
<programlisting>
[DEFAULT]
DEPLOYMENT_DIRECTORY=/home/infinisql/infinisql_built
username: infinisql
sshkey: /home/infinisql/.ssh/id_rsa
ssh: /usr/bin/ssh
infinisqld: %(DEPLOYMENT_DIRECTORY)s/sbin/infinisqld
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld1.log
globaladminpassword: passw0rd
cfghostport: *:11520
cfgremotehostport: %(IPADDR)s:11520
mgmthost:
listenhost: *
listenport: 11521
ibgatewayhostport: %(IPADDR)s:11530
pghost: *
pgport: 15432
transactionagents: 8
engines: 4
ibgateways: 1
obgateways: 1
anonymousping: 1
badloginmessages: 1

IPADDR=127.0.0.1

[global]
userschemamgrnode: 1
deadlockmgrnode: 1
activereplica: 0

[node_1]
replica: 0
member: 0

[node_2]
replica: 0
member: 1
cfghostport: *:21520
cfgremotehostport: %(IPADDR)s:21520
listenport: 21521
ibgatewayhostport: *:21530
logfile: %(DEPLOYMENT_DIRECTORY)s/var/infinisqld2.log
pgport: 15433
</programlisting>
</example>

</section>
</article>

</part>

<!-- follows is good yo -->
<part>
  <title><trademark>InfiniSQL</trademark> User Reference Manual</title>  
<partintro>
<para>
This is the reference manual for using InfiniSQL. It includes descriptions
of SQL capabilities, schema management, user management, and the stored
procedure API. There's also an overview of how they tie together.
</para>
</partintro>

<chapter>
<title>Using InfiniSQL</title>
<para>
Users can interact with a running InfiniSQL cluster over TCP on each node in
the <varname>activereplica</varname>. For the time being, that needs to be
configured as 0. From a user's standpoint, there is no difference between
any of the nodes in a replica other than TCP/IP connection settings. All
users, schemata, and data are accessible from each node in the cluster.
</para>
<para>
The workflow for using InfiniSQL, once up and running, is as follows:
<orderedlist>
  <listitem>
    <para>
      Login as administrative user and create a domain and a user
associated with the new domain.
    </para>
  </listitem>
<listitem>
  <para>
    Login as newly-created user. Create schema and tables and indices.
  </para>
</listitem>
<listitem>
  <para>
Optionally compile SQL statements, create stored procedures, and load them.
  </para>
</listitem>
<listitem>
  <para>
    Login as newly-created user on SQL interface. Manipulate data via SQL.
  </para>
</listitem>
</orderedlist>
User and Schema Management is accomplished via a distinct TCP/IP port and
wire protocol from those used for SQL. This is because the means to
manipulate users and schema objects was implemented in InfiniSQL before the
SQL capabilities were added. It is planned to deprecate the original, raw
interface, in favor of the SQL interface, but for the time, this raw
interface is the only way to accomplish user and schema administration tasks.
</para>
</chapter>

<chapter>
<title>User and Schema Management</title>
<para>
Each schema and user is associated with one and only one particular domain.
There is a special domain called <quote><varname>_global</varname></quote>
from which all other domains and users are created. This is the only domain
contained in an InfiniSQL cluster when it is started. Tied to the
<varname>global</varname> domain is the username <varname>admin</varname>.
This user's password is set in the configuration parameter
<varname>globaladminpassword</varname>. The TCP/IP connection settings for
this interface are described in the configuration parameters
<varname>listenhost</varname> and <varname>listenport</varname>.
</para>
<para>
All user and schema management capabilities are available through
<command>perl</command> subroutines contained in 
<filename>scripts/infinisql.plib</filename> in the source tree. The specific
wire protocol format is expressed in this file, as well as in
<filename>infinisqld/TransactionAgent.cc</filename>. But using the
<command>perl</command> subroutines is definitely the fastest way to get up
and running. Simply put a line that says <quote><code>require 'infinisql.plib';</code></quote>
early in a perl script, and use the routines with the appropriate commands.
</para>

<section xml:id="perlapi">
<title>
  Perl API for User and Schema Management
</title>
<para>
  Examples for use of these functions abound in the <filename>scripts/</filename> and <filename>scripts/benchmark/</filename> directories.
</para>

  <refentry xml:id="connect">
    <refmeta>
        <refentrytitle>connect</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>connect</refname>
        <refpurpose>open TCP connection to InfiniSQL node</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;connect(host, port);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>send</secondary></indexterm>
            <indexterm><primary>connect function</primary></indexterm>
    
        <function>connect</function> to InfiniSQL node on
<varname>host:port</varname>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="send">
    <refmeta>
        <refentrytitle>send</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>send</refname>
        <refpurpose>send a command</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;send(command, args...);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>send</secondary></indexterm>
            <indexterm><primary>send command function</primary></indexterm>
    
        <function>send</function> <varname>command</varname> with list
of arguments. Command and all arguments must be string-type. Either enclosed in single or double-quotes, or SCALAR variables whose values were assigned in quotes. So, sending the argument 4 must be done as <quote>4</quote>, for instance.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="describeresponse">
    <refmeta>
        <refentrytitle>describeresponse</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>describeresponse</refname>
        <refpurpose>show response of sent command</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;describeresponse(&amp;send(host, port));
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>describeresponse command</secondary></indexterm>
            <indexterm><primary>describeresponse function</primary></indexterm>
    
Describes response from a command submitted via <function>send</function>
function. There are at least 2 lines of output. The first line has 3 integer values separated by tabs. The first 2 values are the length of the response
string from the server. The 3rd value is the response code. 0 means
successful command completion, non-zero is otherwise. The response codes are defined in <filename>infinisqld/infinisql_defs.h</filename>.
Subsequent lines of output are results of the command, if any. If the command
returns no data, then a 0 is present on the second line of output.
      </para>
      </refsect1>
 </refentry>



  <refentry xml:id="disconnect">
    <refmeta>
        <refentrytitle>disconnect</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>disconnect</refname>
        <refpurpose>close TCP connection to InfiniSQL node</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;disconnect;
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>disconnect</secondary></indexterm>
            <indexterm><primary>disconnect function</primary></indexterm>
    
        <function>disconnect</function> the socket
created by a previous call to <function>connect</function>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="fireforget">
    <refmeta>
        <refentrytitle>fireforget</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>fireforget</refname>
        <refpurpose>send command without collecting response</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>
    &amp;fireforget(command, args...);
  </code>
</para>    
    </refsynopsisdiv>  
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>fireforget</secondary></indexterm>
            <indexterm><primary>send command function with no wait for response</primary></indexterm>
    
Like the <function>&amp;send</function> subroutine, but don't wait for response
from server. This cannot be used in conjunction with <function>&amp;describeresponse</function>.
      </para>
      </refsect1>
 </refentry>

  <refentry xml:id="getcommand">
    <refmeta>
        <refentrytitle>getcommand</refentrytitle>
      </refmeta>  
      <refnamediv>
      <refname>getcommand</refname>
        <refpurpose>read commands from standard input</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <funcsynopsis>
        <funcsynopsisinfo>
require 'infinisql.plib';
        </funcsynopsisinfo>
</funcsynopsis>
<para>
  <code>&amp;describeresponse(&amp;send(&amp;getcommand));</code>
</para>
    </refsynopsisdiv>
      <refsect1><title>Description</title>
      <para><indexterm><primary>perlfunctions</primary>
                         <secondary>getcommand</secondary></indexterm>
            <indexterm><primary>getcommand function</primary></indexterm>
    
Reads commands from standard input. The first line is the command itself.
Subsequent commands are arguments. EOF (CTRL-d) on an empty line submits the
command and arguments. Output of <function>&amp;getcommand</function> should be
fed to <function>&amp;send</function>.
      </para>
      </refsect1>
 </refentry>

</section>

<section>
<title>User and Schema Commands</title>
<para>
These commands are used to login via the raw TCP interface and then to
administer user and schema objects. The InfiniSQL perl subroutine
<function>&amp;send</function> can be used to submit these commands. Each
command and
argument should be sent as a quoted string, including numeric values. This
interface will be deprecated in the near future, but is currently the only
way to do necessary activities, such as creating users, tables, and so on.
The basic steps necessary to prepare for SQL data manipulation are as follows:

<orderedlist>
  <listitem>
    <para>
      <function>&amp;connect(...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("login", &lt;admin credentials&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createdomain", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createuser", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("logout")</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;connect(...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("login", &lt;credentials created above&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createschema")</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("createtable", ...)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;1st column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;2nd column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("addcolumn", &lt;nth column info&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("compile", &lt;UPDATE accounttable SET balance += 1000000 where username='mystore'&gt;)</function>
    </para>
  </listitem>
  <listitem>
    <para>
      <function>&amp;send("loadprocedure", &lt;GimmeMoney.so&gt;)</function>
    </para>
  </listitem>

</orderedlist>

<note><para>
The previous commands are not necessarily syntactically correct, but are
displayed for illustration of the workflow. Refer to the specific reference
entries for each command for correct usage.</para></note>

From here, it's possible to log in and manipulate data in the created tables
either with ad hoc SQL commands and with any stored procedures that have
been loaded.

</para>

<refentry xml:id="login">
<refmeta>
  <refentrytitle>login</refentrytitle>
</refmeta>
<refnamediv>
  <refname>login</refname>
  <refpurpose>login to an InfiniSQL node via the raw interface</refpurpose>
</refnamediv>
<refsect1>
  <title>login</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
  <listitem>
    <para>
      username
    </para>
  </listitem>
  <listitem>
    <para>
      password
    </para>
  </listitem>
</itemizedlist>
Login to InfiniSQL. For a newly-started cluster, the only domain is "_global"
and its only user is "admin". The password is set in the config parameter
<varname>globaladminpassword</varname>.
</para>
<example>
<title>login example</title>
  <para>&amp;send("login", "_global", "admin", "passw0rd");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="logout">
<refmeta>
  <refentrytitle>logout</refentrytitle>
</refmeta>
<refnamediv>
  <refname>logout</refname>
  <refpurpose>logout from an InfiniSQL node via the raw interface</refpurpose>
</refnamediv>
<refsect1>
  <title>logout</title>
<para>
No parameters.
</para>
<para>
Logout of InfiniSQL. The TCP/IP connection is also severed, so
<function>&amp;connect</function> needs to be submitted before
<function>login</function> to login again.

</para>
<example>
<title>logout example</title>
  <para>&amp;send("logout");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createdomain">
<refmeta>
  <refentrytitle>createdomain</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createdomain</refname>
  <refpurpose>create domain</refpurpose>
</refnamediv>
<refsect1>
  <title>createdomain</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
</itemizedlist>
Create a domain called <varname>domainname</varname>. This command can
only be executed by the <varname>admin</varname> user of the
<varname>_global</varname> domain.
</para>
<example>
<title>createdomain example</title>
  <para>&amp;send("createdomain", "texas");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createuser">
<refmeta>
  <refentrytitle>createuser</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createuser</refname>
  <refpurpose>create a user</refpurpose>
</refnamediv>
<refsect1>
  <title>createuser</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      domainname
    </para>
  </listitem>
  <listitem>
    <para>
      username
    </para>
  </listitem>
  <listitem>
    <para>
      password
    </para>
  </listitem>
</itemizedlist>
Creates user <varname>username</varname> associated with domain
<varname>domainname</varname> with password <varname>password</varname>.
This command can
only be executed by the <varname>admin</varname> user of the
<varname>_global</varname> domain.
</para>
<example>
<title>createuser example</title>
  <para>Create user <varname>mayor</varname> in domain
<varname>texas</varname> with password <varname>austin</varname>:
  </para>
<para>
&amp;send("createuser", "texas", "mayor", "austin");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createschema">
<refmeta>
  <refentrytitle>createschema</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createschema</refname>
  <refpurpose>create schema</refpurpose>
</refnamediv>
<refsect1>
  <title>schema</title>
<para>
No Parameters.
</para>
<para>
Create a schema associated with the logged in domain. Only one schema
can exist per domain, and a schema must be present for tables and indices
to be created.
</para>
<example>
<title>createschema example</title>
  <para>&amp;send("createschema");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="createtable">
<refmeta>
  <refentrytitle>createtable</refentrytitle>
</refmeta>
<refnamediv>
  <refname>createtable</refname>
  <refpurpose>create a table</refpurpose>
</refnamediv>
<refsect1>
  <title>createtable</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      tablename
    </para>
  </listitem>
</itemizedlist>
Returns numeric tableid.
</para>
<para>
Create a table within schema of logged-in domain. Unlike SQL's <code>CREATE TABLE</code>, this only creates a bare table with no columns or indices.
</para>
<example>
<title>createtable example</title>
  <para>&amp;send("createtable", "mastertable");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="addcolumn">
<refmeta>
  <refentrytitle>addcolumn</refentrytitle>
</refmeta>
<refnamediv>
  <refname>addcolumn</refname>
  <refpurpose>adds a column and optional index to a table</refpurpose>
</refnamediv>
<refsect1>
  <title>addcolumn</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      tableid
    </para>
  </listitem>
  <listitem>
    <para>
      type
    </para>
  </listitem>
  <listitem>
    <para>
      length (0 for all <varname>type</varname>s other than <varname>charx</varname>
    </para>
  </listitem>
  <listitem>
    <para>
      columnname
    </para>
  </listitem>
  <listitem>
    <para>
      indextype
    </para>
  </listitem>
</itemizedlist>
Returns numeric columnid of newly created column.
</para>
<para>
Create a new column with optional index. At least one column per table
must have an index, or else <code>SELECT</code> will not be able to retrieve
data. <varname>tableid</varname> is the return value from the 
<function>createtable</function> call on the associated table.
</para>

<para>
The possible data types are as follows, with their descriptions.
<itemizedlist>
  <listitem>
    <para>
      <varname>int</varname>: 64bit signed integer
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>bool</varname>: 0 or 1
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>float</varname>: 128bit floating point
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>char</varname>: single 8-byte character
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>charx</varname>: <varname>length</varname> 8-byte characters
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>varchar</varname>: characters of arbitrary length
    </para>
  </listitem>
</itemizedlist>

Indextypes are:
<itemizedlist>
  <listitem>
    <para>
      <varname>none</varname>: no index type
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>unique</varname>: all values must be unique (while allowing multiple nulls)
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>nonunique</varname>: values need not be unique
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>uniquenotnull</varname>: values unique, with no nulls. Equivalent to SQL <code>PRIMARY KEY</code>
    </para>
  </listitem>
  <listitem>
    <para>
      <varname>nonuniquenotnull</varname>: values need not be unique, and no nulls allowed
    </para>
  </listitem>
</itemizedlist>

</para>
<example>
<title>addcolumn example</title>
  <para>Create integer column <varname>accountid</varname> on tableid 1
with unique and not null constraints:
  </para>
<para>&amp;send("addcolumn", "1", "int", "0", "accountid", "uniquenotnull");</para>
<para>
  Other examples abound under the <filename>scripts/</filename> directory.
</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="compile">
<refmeta>
  <refentrytitle>compile</refentrytitle>
</refmeta>
<refnamediv>
  <refname>compile</refname>
  <refpurpose>compile a SQL statement</refpurpose>
</refnamediv>
<refsect1>
  <title>compile</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      statementname
    </para>
  </listitem>
  <listitem>
    <para>
      statement
    </para>
  </listitem>
</itemizedlist>
Returns <varname>statementname</varname>.
</para>
<para>
Compile a SQL statement for use in stored procedures. Parameters for the
statement are within the statement, and are of the form <code>:[0-9]+</code>.
Parameters must start at 0, and increment in single units. Allowed parameters
are for column values to insert, update, or in search expressions. Table and
column names cannot be stored procedure parameters.
</para>
<example>
<title>compile example</title>
  <para>&amp;send("compile", "creditseller", "UPDATE accountstable SET balance = balance + :0 where accountid = :1");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="loadprocedure">
<refmeta>
  <refentrytitle>loadprocedure</refentrytitle>
</refmeta>
<refnamediv>
  <refname>loadprocedure</refname>
  <refpurpose>load a stored procedure</refpurpose>
</refnamediv>
<refsect1>
  <title>loadprocedure</title>
<para>
Parameters:
<itemizedlist>
  <listitem>
    <para>
      pathname
    </para>
  </listitem>
  <listitem>
    <para>
      procedurename
    </para>
  </listitem>
</itemizedlist>
Returns <varname>procedurename</varname>.
</para>
<para>
Load a previously-compiled stored procedure into each running
<command>infinisqld</command> instance in the cluster. This stored
procedure is a C++ module which gets dynamically loaded. It must be
present as <filename>pathname</filename> on every host which runs
1 or more <command>infinisqld</command> nodes. Stored procedures must
be loaded after SQL statements which they contain are
<command>compile</command>d. The <varname>procedurename</varname> must
correspond to the procedure name within the stored procedure source, explained
more fully in a separate part of this documentation.
</para>
<example>
<title>loadprocedure example</title>
  <para>&amp;send("loadprocedure", "/home/infinisql/infinisql_built/procs/PgbenchNoinsertProc.so", "PgbenchNoInsert");</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="ping">
<refmeta>
  <refentrytitle>ping</refentrytitle>
</refmeta>
<refnamediv>
  <refname>ping</refname>
  <refpurpose>Verify up and running</refpurpose>
</refnamediv>
<refsect1>
  <title>ping</title>
<para>
No Parameters.
</para>
<para>
Verify that <command>infinisqld</command> node is up and running and
able to answer user and schema management commands.
</para>
<example>
<title>ping example</title>
  <para>&amp;describeresponse(&amp;send("ping"));</para>
</example>
</refsect1>
</refentry>

</section>

</chapter>

<chapter>
<title>SQL Reference</title>
<para>
InfiniSQL uses the <link xl:href="http://www.postgresql.org/docs/9.2/static/protocol.html">PostgreSQL Frontend/Backend Protocol, Version 3</link>. This
means that any PostgreSQL client version 7.4 or later, regardless of platform
or language, should be able to connect to InfiniSQL. InfiniSQL does not
support PostgreSQL compiled statements, which are frequently implemented
by default on client side libraries, such as for <command>perl</command>.
InfiniSQL has been tested using the <command>psql</command> command-line
tool as well as the <function>DBD::Pg</function> <command>perl</command>
library. For <command>perl</command>, the <varname>pg_server_prepare</varname> parameter to connect
via <function>DBD::Pg</function> must be set to 0. Similar configuration
for other languages may need to be performed in order for those libraries to
work with InfiniSQL.
<note><para>No code from PostgreSQL, except for macro definitions
(in <filename>infinisqld/pgoids.h</filename>)
necessary to implement the Frontend/Backend Protocol, is included in
InfiniSQL.</para></note>

InfiniSQL does not support SSL (yet), so connections are unencrypted. Also,
InfiniSQL only listens on TCP/IP ports, and not UNIX domain sockets. The
TCP/IP host and port for each node are configured by the <varname>pghost</varname> and <varname>pgport</varname> parameters in <filename>etc/infinisqlmgr.conf</filename>. Clients can connect to any running node. All database contents
are available identically from all nodes. InfiniSQL only supports
clear text passwords currently--clients normally negotiate this properly,
but if you try to force InfiniSQL to use some other method, such as MD5
hashing, then authentication will fail. The InfiniSQL notion of domain
is equivalent to PostgreSQL's database. So, connecting to a database via
PostgreSQL client maps to the domain created previously.

<example>
  <title>
    Connecting via <command>psql</command>.
  </title>
<programlisting>
PGSSLMODE=disable psql -h 127.0.0.1 -p 15432 -d texas -U mayor
</programlisting>
<para>
  Connects to <command>infinisqld</command> node on localhost port 15432.
Domain name is "texas" and userid "mayor". A password prompt appears next.
If no dbname is sent, then the server will attempt to authenticate the 
username with the same domainname, just like a PostgreSQL server
</para>
</example>

<note>
  <para>
    Not all capabilities available through commands in the <command>psql</command> client are functional when connected to an InfiniSQL database. If they send
a command to the server which is currently unsupported, such as <command>\d</command>, then an error message will be returned. Those commands which do not
communicate with the backend work properly.
  </para>
</note>

If a query does not succeed, then an error response is generated. Only
a handful of error types and messages are currently emitted.
<note>
  <para>
    One error type returned is 55P03 <quote>lock not available</quote>. This
happens when a transaction attemps to lock a record which is
already locked. A workaround is to retry the transaction until
the message goes away. If the record never unlocks, it's because some
other transaction has never released it. Deadlock managment is currently
not implemented. These limitations will be corrected in a release very
soon.
  </para>
</note>


</para>

<refentry xml:id="insert">
<refmeta>
  <refentrytitle>INSERT</refentrytitle>
</refmeta>
<refnamediv>
  <refname>insert</refname>
  <refpurpose>Inserts records into a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>insert</title>
<para>
INSERT INTO &lt;tablename&gt; VALUES (&lt;value list&gt;);
</para>
<note>
  <para>
    All column values for a record must be listed, comma-separated,
 in column order. InfiniSQL does not yet support default column values.
  </para>
</note>
<example>
<title>INSERT example</title>
  <para>INSERT INTO mastertable VALUES (5, false, 88);</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="select">
<refmeta>
  <refentrytitle>SELECT</refentrytitle>
</refmeta>
<refnamediv>
  <refname>select</refname>
  <refpurpose>Retrieves records from a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>select</title>
<para>
SELECT &lt;* | column list&gt; FROM &lt;tablename&gt; [WHERE &lt;search expression&gt;] [FOR UPDATE] [NO LOCK];
</para>
<para>
Only a single table can be included--InfiniSQL currently does not support
joins. The search expression supports the following SQL-92 predicates:
COMPARISON (=, &lt;&gt;, &lt;, &gt;, &lt;=, and &gt;=), BETWEEN, NULL, IN, LIKE, NOT BETWEEN,
NOT NULL, NOT IN, and NOT LIKE.
</para>
<para>
These are the most common search expression predicates in use.  These
predicates can be combined with AND, and OR, such as: <quote><code>WHERE cola=7 AND colc BETWEEN 7 AND 43</code></quote>. NOT is only supported where listed above. <quote><code>NOT (WHERE cola=7 OR colc BETWEEN 7 AND 43)</code></quote>, for example, is not supported by InfiniSQL. Other predicates,
such as EXISTS and UNIQUE, will be implemented in an upcoming release.
The fields in the search expression must have some index type assigned when
created by <command>addcolumn</command>. 
</para>
<para>
By default, a read lock is acquired for rows returned. That can be 
over-ridden by optional "FOR UPDATE" and "NO LOCK" clauses.
The FOR UPDATE clause, if present,
puts a write lock on any records returned.
A write lock is necessary for subsequent SQL commands in the transaction,
such as UPDATE or DELETE, to modify the record. NO LOCK, if present, places
no type of lock on the record. NO LOCK may have performance advantages,
but also data quality implications.
</para>
<para>
The script
<command>scripts/regression.pl</command> attempts to test all of the
supported predicate types and combinations.
</para>
<example>
<title>SELECT example</title>
  <para>SELECT * FROM mastertable WHERE accountid >= 25;</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="update">
<refmeta>
  <refentrytitle>UPDATE</refentrytitle>
</refmeta>
<refnamediv>
  <refname>update</refname>
  <refpurpose>Modifies records in a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>update</title>
<para>
UPDATE &lt;tablename&gt; SET &lt;list of fieldname [=, +=, -=, *=, /=] [-+]value, ...&gt; [WHERE &lt;search expression&gt;];
</para>
<para>
The search expression capabilities are the same as for SELECT.
</para>
<example>
<title>UPDATE example</title>
  <para>UPDATE intuniquetable set intunique2=60 WHERE intunique2=50;</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="delete">
<refmeta>
  <refentrytitle>DELETE</refentrytitle>
</refmeta>
<refnamediv>
  <refname>delete</refname>
  <refpurpose>Deletes records in a database.</refpurpose>
</refnamediv>
<refsect1>
  <title>update</title>
<para>
DELETE FROM &lt;tablename&gt; [WHERE &lt;search expression&gt;];
</para>
<para>
The search expression capabilities are the same as for SELECT.
</para>
<example>
<title>DELETE example</title>
  <para>DELETE FROM liketable WHERE charxcol LIKE 'abcdefghijklmnopqrstuvwxyz';</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="selectstoredproc">
<refmeta>
  <refentrytitle>SELECTSTOREDPROC</refentrytitle>
</refmeta>
<refnamediv>
  <refname>selectstoredproc</refname>
  <refpurpose>Execute stored procedure.</refpurpose>
</refnamediv>
<refsect1>
  <title>selectstoredproc</title>
<para>
SELECT &lt;procname&gt; (&lt;parameterlist&gt;);
</para>
<para>
The results of this query are formatted like those from a SELECT query.
</para>
<example>
<title>SELECTSTOREDPROC example</title>
<para>
  SELECT SqlProc (20, 90, 35);
</para>
</example>
</refsect1>
</refentry>

<refentry xml:id="transactions">
<refmeta>
  <refentrytitle>TRANSACTIONS</refentrytitle>
</refmeta>
<refnamediv>
  <refname>transactions</refname>
  <refpurpose>Perform transactions.</refpurpose>
</refnamediv>
<refsect1>
  <title></title>
<para>
<quote>BEGIN [WORK];</quote> to start transactions. <quote>ROLLBACK [WORK]</quote> to roll back. <quote>COMMIT [WORK]</quote> to commit. <quote>END</quote> is
a synonym for <quote>COMMIT</quote>.
</para>
<para>
InfiniSQL behaves with auto-commit based on the variable
<varname>session_isautocommit</varname> in the Pg class 
(<filename>infinisqld/Pg.cc &amp; infinisqld_Pg.h</filename>). It is currently
set to <command>true</command> in the source. Auto-commit is where the
server puts each individual statement into a transaction and executes it
if there is no active transaction when the statement was typed. If a 
transaction is manually started with <command>BEGIN</command>, then
auto-commit does not apply. If a statement causes an error while in a
transaction, then no further statements will be executed until <command>ROLLBACK</command> is received.
</para>
</refsect1>
</refentry>

</chapter>

<article>
  <title>
    Future SQL Capabilities
  </title>
<section>
  <title>Future SQL Capabilities</title>
<para>
Put simply, if the SQL capabilities are not described above, then they
likely aren't available in InfiniSQL as of release 0.1.2-alpha. Places
to look in the code mainly include <filename>infinisqld/lexer.ll, parser.yy,
Asts.cc, infinisql_Asts.cc, Larxer.cc, infinisql_Larxer.cc, Transaction.cc,
 infinisql_Transaction.h, Pg.cc, and infinisql_Pg.h</filename>.
Missing
standard features are planned for future releases. Some are more simple
to implement than others. The InfiniSQL code base is able to support
all standard SQL features while still maintaining its uniquely scalable
transaction processing capabilities. Much of the code for these
features has already been written, but not yet completed.
It's just a matter of development
effort to bring these capabilities to life.

These include, but aren't limited to:

<itemizedlist>
  <listitem>
    <para>
      Lock &amp; deadlock management
    </para>
  </listitem>
  <listitem>
    <para>
Joins
    </para>
  </listitem>
  <listitem>
    <para>
Subqueries
    </para>
  </listitem>
  <listitem>
    <para>
ORDER BY, GROUP BY (aggregate), HAVING clauses
    </para>
  </listitem>
  <listitem>
    <para>
CREATE TABLE, CREATE COLUMN, etc.: all data definition, to deprecate
the commands in the raw interface, such as <command>createtable</command>,
<command>addcolumn</command>, and the like.
    </para>
  </listitem>
</itemizedlist>
</para>
</section>
</article>

<chapter>
<title>Stored Procedure API</title>
<para>

</para>
<refentry xml:id="storedproc">
<refmeta>
  <refentrytitle>storedproc</refentrytitle>
</refmeta>
<refnamediv>
  <refname>storedproc</refname>
  <refpurpose>Stored Procedure Programming</refpurpose>
</refnamediv>
<refsect1>
  <title>storedproc</title>
<para>
Working examples of InfiniSQL stored procedures and how they are built
are located in the <filename>procs/</filename> directory of the source
distribution. The <command>makem.sh</command> script builds them and
deploys to the <filename>procs/</filename> directory in the installation
directory corresponding to the <code>--prefix</code> option to
<command>./configure</command>. This installation directory must be passed as
an argument to <command>makem.sh</command>.
</para>
<para>
  Stored procedures are dynamically-loaded custom C++ classes. The structure and
contents of the source files are driven in part by requirements for
dynamically loaded C++ classes and functions. This <link xl:href="http://www.isotton.com/devel/docs/C++-dlopen-mini-HOWTO/C++-dlopen-mini-HOWTO.html">HOWTO</link> is a good basis for understanding how dynamic C++ modules are implemented.
Stored procedures link against a single library, <filename>&lt;installationdir&gt;/lib/libinfinisql.so</filename>. They must include multiple headers, however,
from <filename>&lt;installationdir&gt;/include/</filename>. Ideally, the
header requirements would be simplified from refactoring the API code, but
for the time being, multiple headers are necessary. Class factory function
prototypes to instantiate and delete stored procedure objects are as follows:

<funcsynopsis>
  <funcprototype>
    <funcdef>extern "C" ApiInterface* <function>InfiniSQL_&lt;domainname&gt;_&lt;procedurename&gt;_create</function></funcdef>
<paramdef>
  TransactionAgent *<parameter>taPtr</parameter>
</paramdef>
<paramdef>
  ApiInterface *<parameter>pgPtr</parameter>
</paramdef>
<paramdef>
  void <parameter>destructorPtr</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

<funcsynopsis>
  <funcprototype>
    <funcdef>extern "C" ApiInterface* <function>InfiniSQL_&lt;domainname&gt;_&lt;procedurename&gt;_destroy</function></funcdef>
<paramdef>
  ApiInterface *<parameter>p</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

<varname>domainname</varname> is that submitted by <command>createdomain</command> and <varname>procedurename</varname> is from <command>loadprocedure</command>, and invoked through SQL with <quote><code>SELECT &lt;procname&gt; (&lt;parameterlist&gt;)</code></quote>. Since the class
factories are global functions, this ensures that no name space conflict
occurs between domains. 
<note>
  <para>
    Since stored procedures are dynamically loaded C++ programs, there is
no way for <command>infinisqld</command> to protect from fatal errors
caused by custom stored procedure code.
  </para>
</note>

</para>
<para>
To avoid name conflicts, the custom class <emphasis>should</emphasis>
follow a similar naming convention as that of the factory functions--but
the author has set a bad example in the shipped procedures themselves.
The class must inherit from <classname>class ApiInterface</classname>.
</para>
<para>
  Beyond syntactic requirements--which should be inferable quite easily
from the source code anyway--a very important characteristic of stored
procedure programming is that of continuations. <command>infinisqld</command>
makes heavy use of asynchronous event processing to allow a relatively
small number of threads to handle massive concurrent workloads. Most
transaction operations, such as performing SQL queries, involve message
passing between multiple threads. No threads block waiting for replies.
Instead, they store the state of the transaction and proceed to work
on other activities as events occur. When an appropriate response message
is received, the transaction picks up where it left off. InfiniSQL
implements continuations by storing the return function and
its intended parameter values to be called later. This is home-brew
continuations. Better solutions likely exist, such as <function>setjmp/longjmp</function>, but that can be solved in the future through refactoring. The
return function for stored procedures must have the following
definition:

<funcsynopsis>
  <funcprototype>
    <funcdef>void <function>&lt;continueFunc[12]&gt;</function></funcdef>
<paramdef>
  int64_t <parameter>entrypoint</parameter>
</paramdef>
<paramdef>
  void *<parameter>statePtr</parameter>
</paramdef>
  </funcprototype>
</funcsynopsis>

Allowable function names are from the <classname>class ApiInterface</classname>, and are
<function>continueFunc1</function> and
<function>continueFunc2</function>.
Other continuation functions which must be defined in each stored procedure,
but which also <emphasis>must not</emphasis> be used, are
<function>continuePgFunc</function>,
<function>continuePgCommitimplicit</function>,
<function>continuePgCommitexplicit</function>,
<function>continuePgRollbackimplicit</function>, and
<function>continuePgRollbackexplicit</function>. These functions are used
by <classname>class Pg</classname>, which also inherits from
<classname>class ApiInterface</classname>. All custom logic for the
stored procedure must occur either in the constructor function,
<function>continueFunc1</function> or <function>continueFunc2</function>.
<varname>entrypont</varname> can be used to keep track of state, such as through
a <function>switch</function> statement within <function>contnueFunc1</function>
or <function>continueFunc2</function>. Alternately, state can be maintained
in class member variables.
</para>

<refsect2>
<title>Relevant ApiInterface Member Variables</title>
<para>
  <itemizedlist>
    <listitem>
      <para>
	<varname>ApiInterface *pgPtr</varname>: Pg
object which called stored procedure. Also the object to which control will
return when procedure exits.
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>TransactionAgent *taPtr</varname>: TransactionAgent
actor thread object associated with <varname>pgPtr</varname>
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>int64_t domainid</varname>: numeric indentifier for 
associated <varname>domainname</varname>
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>Transaction *transactionPtr</varname>: associated Transaction object 
(or NULL if no open transaction)
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>vector&lt;std::string&gt; pgPtr->statementPtr->queries[0].storedProcedureArgs</varname>: Arguments passed to stored procedure as formatted strings
      </para>
    </listitem>
    <listitem>
      <para>
	<varname>struct results_s results</varname>: results from transaction
function calls
      </para>
    </listitem>
  </itemizedlist>
</para>
</refsect2>

<refsect2>
  <title>ApiInterface Functions</title>
<para>
  This is where the storedprocedure interacts with the database. With the
exception of <function>beginTransaction</function>, all functions require
continuation to occur. The stored procedure must inform these functions
how and where to return to the stored procedure for execution once the
requested activity has been accomplished.

<note>
<para>
Perhaps the most important
thing to remember about calling these functions is that control flow
must exit the stored procedure as soon as possible after calling! It is
a good idea to use a <code>return;</code> statement as soon as possible
after calling. This is to ensure correct program flow. Returning from the
stored procedure causes control to flow back to allow processing of
other transaction events.
</para>
</note>

<note>
  <para>
    Don't block or sleep! Each stored procedure invocation is performed
in a thread which may be handling thousands of other transactions at the
same time. This means that time-wasting activities such as <function>sleep</function> or blocking i/o, will cause processing to slow down for all other
transactions handled by the TransactionAgent thread.
  </para>
</note>

</para>

<refsect3>
  <title>beginTransaction</title>
<funcsynopsis>
  <funcprototype>
    <funcdef>void <function>beginTransaction</function></funcdef>
<void></void>
  </funcprototype>
</funcsynopsis>
<para>
Creates a Transaction object. Places a pointer to the object in <varname>transactionPtr</varname>. Only one Transaction can be open at a time for the stored
procedure. The stored procedure should check the value of <varname>transactionPtr</varname> before calling this--if it is not null, then it likely means
that something has created a transaction already. Calling this function will
cause another open transaction to leak away. This function is not the start
of a continuation, so program flow following this function can proceed
directly.
</para>
</refsect3>

<refsect3>
  <title>execStatement</title>
<funcsynopsis>
  <funcprototype>
    <funcdef>bool <function>execStatement</function></funcdef>
<paramdef>const char *<parameter>stmtname</parameter></paramdef>
<paramdef>vector&lt;string&gt;&amp; <parameter>args</parameter></paramdef>
<paramdef>apifPtr <parameter>reentryfunction</parameter></paramdef>
<paramdef>int64_t <parameter>reentrypoint</parameter></paramdef>
<paramdef>void <parameter>reentrydata</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<para>
Executes statement <varname>stmtname</varname> corresponding to that
<command>compile</command>d previously, with <varname>args</varname> as
parameters. The index values of the vector correspond to parameter
numbers. <varname>args[0] &amp; args[1]</varname> become parameters
<varname>:0 &amp; :1</varname>, respectively, and so on.
<varname>reentryfunction</varname> should be a function pointer to the
function which will continue once <varname>stmtname</varname> executes, most
likely either <varname>&amp;ApiInterface::continueFunc1</varname> or
<varname>&amp;ApiInterface::continueFunc2</varname>.
<varname>reentrypoint</varname> and <varname>reentrydata</varname> are
arguments to be passed to <varname>reentryfunction</varname>.
</para>
<para>
  <varname>args</varname> is a vector of formatted strings representing
type and value for each parameter intended for <varname>stmtname</varname>.
<varname>args[n][0]</varname> is a character of type corresponding to
symbol definitions like <varname>OPERAND_.*</varname> in <filename>infinisqld/infinisql_defs.h</filename>. Remaining characters represent the value of the
parameter. Types <type>OPERAND_INTEGER and OPERAND_BOOLEAN</type> are stored as <type>int64_t</type>, and <type>OPERAND_FLOAT</type> as <type>long double</type>. <type>OPERAND_STRING</type>
constitutes a <function>string::sutbstr()</function> from pos 1 through
string::npos. For example, <function>Ast::evaluate()</function> in
<filename>infinisqld/Asts.cc</filename> is a place where these valuables
are manipulated.
</para>
<para>
<emphasis>Return Value</emphasis>
</para>
<para>
  This function returns immediately with either <literal>true</literal> or
<literal>false</literal>. <literal>true</literal> means that <varname>stmtname</varname> exists to be executed. <literal>false</literal> means the opposite.
Make sure that <command>loadprocedure</command> for <varname>stmtname</varname>
executes successfuly before calling <function>execStatement</function>.
</para>

<para><emphasis>Results</emphasis></para>
<para>
  Status in <varname>results.statementStatus</varname>. Anything other
than <literal>STATUS_OK</literal> (0) should be cause to <function>rollback</function>. Results from <command>SELECT</command> are stored in <varname>results.SelectFields</varname> and <varname>results.selectResults</varname>.
From <command>UPDATE, INSERT, DELETE</command>, in <varname>results.statementResults</varname>.
</para>
</refsect3>
    
<refsect3>
  <title>commit</title>
<funcsynopsis>
  <funcprototype>
    <funcdef>void <function>commit</function></funcdef>
<paramdef>apifPtr <parameter>re</parameter></paramdef>
<paramdef>int64_t <parameter>recmd</parameter></paramdef>
<paramdef>void *<parameter>reptr</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<para>
Commits <varname>transactionPtr</varname>.
</para>
<para><emphasis>Results</emphasis></para>
<para>
  <varname>results.statementStatus</varname> gives status. If not 0, then a
<function>rollback</function> should be attempted. <varname>transactionPtr</varname> needs to be <command>delete</command>d once successfully <command>commit</command>ted or else it will leak memory.
</para>
</refsect3>

<refsect3>
  <title>rollback</title>
<funcsynopsis>
  <funcprototype>
    <funcdef>void <function>rollback</function></funcdef>
<paramdef>apifPtr <parameter>re</parameter></paramdef>
<paramdef>int64_t <parameter>recmd</parameter></paramdef>
<paramdef>void *<parameter>reptr</parameter></paramdef>
  </funcprototype>
</funcsynopsis>
<para>
Rolls back <varname>transactionPtr</varname>.
</para>
<para><emphasis>Results</emphasis></para>
<para>
  <varname>results.statementStatus</varname> gives status. If not 0, then 
there isn't much to do. In case of success or failure, <command>delete</command>
<varname>transactionPtr</varname> to avoid a memory leak.
</para>
</refsect3>

</refsect2>


<refsect2>
  <title>
    Sending Results and Exiting
  </title>
<para>
  Stored procedure results are sent as rows and columns from a <command>SELECT</command> query. For InfiniSQL, this means populating the following:
<itemizedlist>
  <listitem>
    <para>pgPtr->results.selectFields</para>
  </listitem>
  <listitem>
    <para>pgPtr->results.selectResults, and</para>
  </listitem>
  <listitem>
    <para>pgPtr->results.statementStatus</para>
  </listitem>
</itemizedlist>

Those objects are described in <filename>infinisqld/infinisql_Pg.h</filename>.
</para>
<para>
  Exiting requires deleting the <classname>Statement</classname> object associated with the client's stored procedure invocation "<code>SELECT Proc (...)</code>", deleting the
current object and then executing the
function to continue the Pg object which called the stored procedure. An
example is in <filename>procs/PgbenchNoinsertProc.cc</filename>
<function>exitProc</function>.
</para>
</refsect2>


</refsect1>

</refentry>
</chapter>

</part>

<part>
<title><trademark>InfiniSQL</trademark> Command and File Reference Manual</title>
<partintro>
<para>
</para>
</partintro>

<chapter>
<title>Files For Operating InfiniSQL</title>
<para>
The files described in this reference are executables and configuration
files used in operating InfiniSQL. They don't include all of the source
files used for building. There are two main directories in which these
files are contained: <filename>sourcedir</filename> and <filename>installationdir</filename>. <filename>sourcedir</filename> is created by doing "<command>git clone git://github.com/infinisql/infinisql.git</command>", or from extracting
a compressed tarfile to initially
retrieve the source. <filename>installationdir</filename> is the destination
passed as the value for <code>--prefix</code> passed to the
<command>./configure</command> script in the resulting build process.
<note>
  <para>
    <filename>installationdir</filename> should be independent from all other
directories, and not be a shared system directory, such as
<filename>/usr/local</filename>. This is to ease management of InfiniSQL.
  </para>
</note>
</para>

<section>
  <title>
    Executables
  </title>

<refentry xml:id="infinisqlmgr.py">
<refnamediv>
  <refname>infinisqlmgr.py</refname>
<refpurpose>InfiniSQL Cluster Startup</refpurpose>
</refnamediv>
<refsect1>
  <title>infinisqlmgr.py</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/infinisqlmgr</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./infinisqlmgr.py</command>
</para>
<para>
  Takes no arguments. Reads contents of <filename>&lt;sourcedir&gt;etc/infinisqlmgr.conf</filename>
and launches all <command>infinisqld</command> node processes. Uses
password-less ssh (unless <varname>mgmthost</varname> parameter is blank).
Exits
after completion. Hangs or prints out a python stack trace if encounters
any errors.
</para>
</refsect1>
</refentry>

<refentry xml:id="infinisqld">
<refnamediv>
  <refname>infinisqld</refname>
<refpurpose>InfiniSQL daemon node process</refpurpose>
</refnamediv>
<refsect1>
  <title>infinisqld</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;installationdir&gt;/sbin</filename>
</para>
<para>
<emphasis>Usage:</emphasis> this is not executed directly, but by <command>infinisqlmgr.py</command>
</para>
<para>
  InfiniSQL server process. Writes informational and error messages based on
<varname>logfile</varname> config parameter.
</para>
</refsect1>
</refentry>

<refentry xml:id="prime_regression.pl">
<refnamediv>
  <refname>prime_regression.pl</refname>
<refpurpose>Prepares InfiniSQL for regression test</refpurpose>
</refnamediv>
<refsect1>
  <title>prime_regression.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./prime_regression.pl -h &lt;hostname&gt;</command>
</para>
<para>
Sets up user &amp; schema objects to prepare for regression test. Connects to
<varname>hostname</varname> on TCP port 11521. Can be any node in the
cluster. Config parameters <varname>listenhost</varname> and
<varname>listenport</varname> are what this script needs to connect to.
</para>
</refsect1>
</refentry>

<refentry xml:id="regression.pl">
<refnamediv>
  <refname>regression.pl</refname>
<refpurpose>SQL regression test</refpurpose>
</refnamediv>
<refsect1>
  <title>regression.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./regression.pl  -h &lt;hostname&gt;</command>
</para>
<para>
Performs SQL regression test. Hundreds of queries.
 Connects to
<varname>hostname</varname> on TCP port 11521. Can be any node in the
cluster. Config parameters <varname>listenhost</varname> and
<varname>listenport</varname> are what this script needs to connect to.
</para>
</refsect1>
</refentry>

<refentry xml:id="entercommands.pl">
<refnamediv>
  <refname>entercommands.pl</refname>
<refpurpose>User and schema management command shell.</refpurpose>
</refnamediv>
<refsect1>
  <title>entercommands.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./entercommands.pl</command>
</para>
<para>
Connects to node on localhost:11521 and sends arbitrary commands through
the raw format, such as <command>login</command>, <command>createtable</command>, and so on. Data entry is described in the description for <function>&amp;getcommand</function>.
</para>
</refsect1>
</refentry>

<refentry xml:id="ping.pl">
<refnamediv>
  <refname>ping.pl</refname>
<refpurpose>Sends raw interface ping command</refpurpose>
</refnamediv>
<refsect1>
  <title></title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./ping.pl</command>
</para>
<para>
Sends InfiniSQL <command>ping</command> to localhost:11521.
</para>
</refsect1>
</refentry>

<refentry xml:id="bm.pl">
<refnamediv>
  <refname>bm.pl</refname>
<refpurpose>Launch benchmark job</refpurpose>
</refnamediv>
<refsect1>
  <title>bm.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>

<para>
<emphasis>Usage:</emphasis> <command>./bm.pl -test=&lt;testtype&gt; [--accountids=&lt;#&gt;][--duration=&lt;# seconds&gt;][--nclients=&lt;#&gt;]
[--bmresultsdir=&lt;somedir&gt;]</command>
</para>
<para>
  Executes benchmark. Distributes client traffic across hosts listed in
<filename>clients</filename>, to hit servers in <filename>daemons</filename>.
Testtypes are either to fill benchmark tables, or to execute the benchmark.
To fill benchmark tables, testtype is either <literal>preparepgbench</literal>
or <literal>preparekeyval</literal>, with accountids sets of rows.
Benchmark testtypes are <literal>procedure</literal>, <literal>procedurenoinsert</literal>, <literal>multistatements</literal>, <literal>setkey</literal>,
and <literal>getkey</literal>. These correspond with files ending in
<filename>.pgb</filename>.
</para>
<para>
  <command>bm.pl</command> ssh's into each client host and executes <command>moforker.pl</command> to launch either fill scripts or InfiniSQL's patched version
of <command>pgbench</command>. <command>pgbench</command> tests run for --duration seconds and launch a total number of --nclients, distributed round-robin across hosts listed in <filename>clients</filename>. <command>pgbench</command> output is written on each benchmark client into directory <filename>--bmresultsdir</filename>.
</para>
<para>
  bm.pl outputs a number representing UNIX time, which is also written
in the files for this particular test written in --bmresultsdir. Just note
the output number and go analyze the data later. Since it's in UNIX time
format, it can be correlated with system resource collection jobs easily.
</para>
<para>
<emphasis>Examples:</emphasis>
</para>
<para>
<command>./bm.pl --test=preparepgbench --accountids=1000000</command>
</para>
<para>
Inserts 1,000,000 rows into each of 3 tables in benchmark database.
</para>
<para>
<command>./bm.pl --test=procedurenoinsert --duration=180 --bmresultsdir=/home/infinisql/bmresults --nclients=504</command>
</para>
<para>
  Connect to InfiniSQL with 100,800 clients (assuming each
<command>pgbench</command> connects with 200) and execute stored procedure
with 3 updates and a select for 180 seconds.
</para>
</refsect1>
</refentry>

<refentry xml:id="collectcpudaemons.sh">
<refnamediv>
  <refname>collectcpudaemons.sh</refname>
<refpurpose>Start resource collection jobs</refpurpose>
</refnamediv>
<refsect1>
  <title>collectcpudaemons.sh</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./collectcpudaemons.sh</command>
</para>
<para>
Starts system resource collection jobs on each host in <filename>daemonhosts</filename>. These scripts are not included in the source distribution, but are
easy to write. The intention of these scripts is to collect data from things
such as top, mpstat, bwm-ng, or anything else, during benchmark runs.
</para>
</refsect1>
</refentry>

<refentry xml:id="deploy.sh">
<refnamediv>
  <refname>deploy.sh</refname>
<refpurpose>Install InfiniSQL on multiple hosts</refpurpose>
</refnamediv>
<refsect1>
  <title>deploy.sh</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./deploy.sh &lt;installationdir&gt; &lt;sourcedir&gt;</command>
</para>
<para>
<command>rsync</command>s directories on command line (must be 2 and only 2)
to each host in <filename>daemonhosts</filename>. Very handy for duplicating
installation files across any number of hosts.
</para>
</refsect1>
</refentry>

<refentry xml:id="fillkeyval.pl">
<refnamediv>
  <refname>fillkeyval.pl</refname>
<refpurpose>Inserts data for keystore benchmarking</refpurpose>
</refnamediv>
<refsect1>
  <title>fillkeyval.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>Called by moforker.pl, not directly</command>
</para>
</refsect1>
</refentry>

<refentry xml:id="fill.pl">
<refnamediv>
  <refname>fill.pl</refname>
<refpurpose>Inserts data for benchmarking 3-update+ stored procedures</refpurpose>
</refnamediv>
<refsect1>
  <title>fill.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>Called by moforker.pl, not directly</command>
</para>
<para>
</para>
</refsect1>
</refentry>

<refentry xml:id="primebm.pl">
<refnamediv>
  <refname>primebm.pl</refname>
<refpurpose>Creates users and tables for benchmarking</refpurpose>
</refnamediv>
<refsect1>
  <title>primebm.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./primebm.pl -h &lt;host&gt;</command>
</para>
<para>
Sets up user &amp; schema objects to prepare for benchmark tests. Connects to
<varname>hostname</varname> on TCP port 11521. Can be any node in the
cluster. Config parameters <varname>listenhost</varname> and
<varname>listenport</varname> are what this script needs to connect to.
</para>
</refsect1>
</refentry>

<refentry xml:id="getlogs.sh">
<refnamediv>
  <refname>getlogs.sh</refname>
<refpurpose>Collect node info and error logs</refpurpose>
</refnamediv>
<refsect1>
  <title>getlogs.sh</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./getlogs &lt;unixsecond&gt;</command>
</para>
<para>
Collects logs from <filename>&lt;installationdir&gt;/var</filename> on each host
listed in <filename>daemonhosts</filename> and copies them to <filename>/home/mtravis/infinisql_built/var</filename>. A directory is created with the <varname>unixsecond</varname> and daemon hostname. This script should probably be
modified somewhat unless your userid is mtravis.
</para>
</refsect1>
</refentry>

<refentry xml:id="killbm.sh">
<refnamediv>
  <refname>killbm.sh</refname>
<refpurpose>Kill benchmark jobs</refpurpose>
</refnamediv>
<refsect1>
  <title>killbm.sh</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./killbm.sh</command>
</para>
<para>
Kills pgbench and perl jobs on each host in <filename>clients</filename>.
</para>
</refsect1>
</refentry>

<refentry xml:id="killdaemons.sh">
<refnamediv>
  <refname>killdaemons.sh</refname>
<refpurpose>Kill <command>infinisqld</command> processes</refpurpose>
</refnamediv>
<refsect1>
  <title>killdaemons.sh</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>killdaemons.sh</command>
</para>
<para>
Kills <command>infinisqld</command> processes on each host in <filename>daemonhosts</filename>.
</para>
</refsect1>
</refentry>

<refentry xml:id="moforker.pl">
<refnamediv>
  <refname>moforker.pl</refname>
<refpurpose>Launch benchmark jobs</refpurpose>
</refnamediv>
<refsect1>
  <title>moforker.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>Not called directly, but by bm.pl.</command>
</para>
<para>
<command>bm.pl</command> executes <command>moforker.pl</command> on each
host in <filename>clients</filename>, which in turn invokes sets of either
<command>fill.pl</command>, <command>fillkeyval.pl</command>, or
<command>pgbench</command>, depending on test type passed to <command>bm.pl</command>.
</para>
</refsect1>
</refentry>

<refentry xml:id="report.pl">
<refnamediv>
  <refname>report.pl</refname>
<refpurpose>Report a Benchmark Run</refpurpose>
</refnamediv>
<refsect1>
  <title>report.pl</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
<emphasis>Usage:</emphasis> <command>./report.pl -t TESTTYPE -s UNIXSECOND</command>
</para>
<para>
Create a report based on a benchmark run. -t and -s arguments are used
to read files on each benchmark client machine within bmresults directory.
</para>
</refsect1>
</refentry>

</section>

<section>
  <title>
    Configs
  </title>
<para>
  These are configuration files.
</para>

<refentry xml:id="infinisql.conf">
<refnamediv>
  <refname>infinisql.conf</refname>
<refpurpose>Configure InfiniSQL</refpurpose>
</refnamediv>
<refsect1>
  <title></title>
<para>
<emphasis>Directory:</emphasis> <filename>sourcedir/etc</filename>
</para>
<para>
Configuration file for InfiniSQL, read by <command>infinisqlmgr.py</command>.
Parameters described in <xref linkend="configfile"/>.
</para>
</refsect1>
</refentry>

<refentry xml:id="clients">
<refnamediv>
  <refname>clients</refname>
<refpurpose>List of benchmark client hosts</refpurpose>
</refnamediv>
<refsect1>
  <title>clients</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
Hosts to be used for benchmark clients. Need to be accessible by
passwordless ssh.
</para>
</refsect1>
</refentry>

<refentry xml:id="daemonhosts">
<refnamediv>
  <refname>daemonhosts</refname>
<refpurpose>List of hosts with <command>infinisqld</command> processes</refpurpose>
</refnamediv>
<refsect1>
  <title>daemonhosts</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
Hosts with InfiniSQL daemon processes running. Need to be accessible by
passwordless ssh.
</para>
</refsect1>
</refentry>

<refentry xml:id="daemons">
<refnamediv>
  <refname>daemons</refname>
<refpurpose>List of each <command>infinisqld</command> node</refpurpose>
</refnamediv>
<refsect1>
  <title></title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
List of each node to be benchmarked. Tab-delimited hostname and
<varname>pgport</varname>. This is the way that benchmark clients will
reach each node.
</para>
</refsect1>
</refentry>

</section>

<section>
  <title>
    Other Files
  </title>
<para></para>

<refentry xml:id="lib">
<refnamediv>
  <refname>lib</refname>
<refpurpose>library</refpurpose>
</refnamediv>
<refsect1>
  <title>lib</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;installationdir&gt;/lib</filename>
</para>
<para>
Library to be linked with for stored procedures. Shared and static
versions.
</para>
</refsect1>
</refentry>

<refentry xml:id="storedprocs">
<refnamediv>
  <refname>storedprocs</refname>
<refpurpose>Compiled stored procedures</refpurpose>
</refnamediv>
<refsect1>
  <title>storedprocs</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;installationdir&gt;/procs</filename>
</para>
<para>
Compiled stored procedure shared objects.
</para>
</refsect1>
</refentry>

<refentry xml:id="infinisql.plib">
<refnamediv>
  <refname>infinisql.plib</refname>
<refpurpose>Perl subroutines</refpurpose>
</refnamediv>
<refsect1>
  <title>infinisql.plib</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
Perl subroutines described in <xref linkend="perlapi"/>. Edit the variables
<varname>$SCRIPTDIR</varname> and <varname>$PROCDIR</varname> to suit
your environment.
</para>
</refsect1>
</refentry>

<refentry xml:id="pgbenchpatch">
<refnamediv>
  <refname>pgbenchpatch</refname>
<refpurpose>Patch for pgbench</refpurpose>
</refnamediv>
<refsect1>
  <title>pgbenchpatch</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/misc</filename>
</para>
<para>
Apply <filename>pgbench_persecond-v1.patch</filename>
against <productname>PostgreSQL</productname> <productnumber>9.2.4</productnumber>. Adds features to facilitate benchmarking.
</para>
<para>
In a PostgreSQL 9.2.4 source directory, patch <command>pgbench</command>:
<screen>patch -p1 &lt; &lt;infinisqlsourcedir&gt;/misc/pgbench_persecond-v1.patch</screen>
If you have not already done so, <command>./configure</command> and then
<command>make</command> PostgreSQL. Then:
<screen>
cd contrib/pgbench
make
sudo cp pgbench /usr/local/bin  
</screen>
</para>
<para>
  The command line arguments and features that this patch adds are as follows:
  <itemizedlist>
    <listitem>
      <para>
	<emphasis>-I:</emphasis> do not abort connection if transaction error is encountered. InfiniSQL returns an error if records are locked, so pgbench
was patched to tolerate this. This is pending a fix, but until then, pgbench needs to carry on. The specific error emitted from the server is written to stderr for each occurrence. The total quantity of transactions is not incremented if there's an error.
      </para>
    </listitem>
    <listitem>
      <para>
	<emphasis>--per-second=NUM:</emphasis> report per-second throughput rate on stdout. NUM is the quantity of transactions in each batch that gets counted. The higher the value, the less frequently <function>gettimeofday</function> gets called. <function>gettimeofday</function> invocation can become a limiting factor as throughput increases, so minimizing it is beneficial. For example, with NUM of 100, time will be checked every 100 transactions, which will cause the per-second output to be in multiples of 100.
      </para>
    </listitem>
    <listitem>
      <para>
	<emphasis>-P PASSWORD:</emphasis> pass the db password on the command line. This is necessary for InfiniSQL benchmarking because hundreds or more separate pgbench processes can be launched, and InfiniSQL requires password authentication. Having to manually enter all those passwords would making benchmarking impossible.
      </para>
    </listitem>
    <listitem>
      <para>
	<emphasis>--urandom:</emphasis> use /dev/urandom to provide seed values for randomness. Without this, multiple pgbench processes are likely to generate the same sequence of "random" numbers. This was noticeable in InfiniSQL benchmarking because of the resulting extremely high rate of locked records from having stored procedures invoked with identical parameter values.
      </para>
    </listitem>
  </itemizedlist>
</para>
</refsect1>
</refentry>

<refentry xml:id="pgbbenchtests">
<refnamediv>
  <refname>pgbenchtests</refname>
<refpurpose>pgbench scripts</refpurpose>
</refnamediv>
<refsect1>
  <title>pgbenchtests</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts/benchmark</filename>
</para>
<para>
Files with .pgb extension.
Tests used by <command>pgbench</command>. Format described under Custom Scripts
heading of <link xl:href="http://www.postgresql.org/docs/9.2/static/pgbench.html">pgbench docs</link>.
</para>
</refsect1>
</refentry>

<refentry xml:id="regression.out-sample">
<refnamediv>
  <refname>regression.out-sample</refname>
<refpurpose>Sample output from regression test</refpurpose>
</refnamediv>
<refsect1>
  <title>regression.out-sample</title>
<para>
<emphasis>Directory:</emphasis> <filename>&lt;sourcedir&gt;/scripts</filename>
</para>
<para>
This is output from a successful <command>regression.pl</command> test.
Use it to compare with output from testing your own installation. The
line count can vary--this is due to inexact matching of floating point
values. Those queries should probably be removed from the regression test
at some point for consistency in test output.
</para>

</refsect1>
</refentry>
</section>

</chapter>
</part>

<part>
  <title><trademark>InfiniSQL</trademark> Source File Reference</title>
<partintro>
  <para>
    This is a listing of each C++ source file in the <filename>&lt;sourcedir&gt;infinisqld/</filename> directory, along with a brief description of the
contents. This is not a full-blown development reference: InfiniSQL's code
is not documented sufficiently (big TODO item) for that, but this document
is intended to help a developer get their feet wet.
  </para>

</partintro>
<chapter>
  <title>Source Files</title>
<sect1>
  <title>Source Corresponds To Header</title>
<para>
  These files have <literal>.cc</literal> corresponding with a single
<literal>.h</literal> file. Each entry describes a pairing like this, of
format <literal>&lt;entry&gt;.cc</literal> and <literal>infinisql_&lt;entry&gt;.h</literal>. Many entries contain a single class, but some have multiple
classes.
</para>

<sect2>
  <title>Applier</title>
<para>
  Applies transactional data modifications as part of synchronous
replication.
</para>
</sect2>
<sect2>
  <title>Asts</title>
<para>
  Abstract Syntax Tree class and Statement class. A SQL statement turns
into these in order to be executed.
</para>
</sect2>
<sect2>
  <title>DeadlockMgr</title>
<para>
Actor which resolves deadlocks.
</para>
</sect2>
<sect2>
  <title>Engine</title>
<para>
Engine actors store and manipulate data. Each engine interacts with a single
partition, and vice versa.
</para>
</sect2>
<sect2>
  <title>Field</title>
<para>
Data Field class (INT, BOOL, VARCHAR, etc).
</para>
</sect2>
<sect2>
  <title>IbGateway</title>
<para>
Inbound Gateway actor. Counterpart to ObGateway. Receives messages over the network from remote senders
and distributes them to their destination actors on the current node.
</para>
</sect2>
<sect2>
  <title>Index</title>
<para>
Index type class (UNIQUE, NONUNIQUE, etc.)
</para>
</sect2>
<sect2>
  <title>Larxer</title>
<para>
Portmanteau of "lexer" and "parser". This class tokenizes, parses and
converts SQL into executable Statement with Abstract Syntax Trees.
</para>
</sect2>
<sect2>
  <title>Listener</title>
<para>
On each host, this actor accepts new connections and distributes incoming
network traffic from clients to Transaction Agents. 
<note>
<para>
There is only one listener per host.
It takes a small amount
of coding effort to allow for multiple listeners per host. But no
workload as yet (benchmarked on 12-core Xeon) has been shown to warrant
multiple listeners. It's very possible that larger hosts may benefit
from distributing incoming TCP/IP traffic across multiple listeners,
and the effort to allow that won't be difficult to implement.
</para>
</note>
</para>
</sect2>
<sect2>
  <title>Mbox</title>
<para>
Mbox* classes perform inter-actor messaging. Mbox is a lockfree
multi producer, single consumer queue.
</para>
</sect2>
<sect2>
  <title>Message</title>
<para>
Message objects of varying types. Each type eventually inherits from the
Message base class. Each type serves a different role in inter-actor
communication.
</para>
</sect2>
<sect2>
  <title>ObGateway</title>
<para>
Outbound Gateway actor. Counterpart to IbGateway. Receives messages from
actors on current node bound for remote nodes. Sends them over the
network to IbGateway.
</para>
</sect2>
<sect2>
  <title>Operation</title>
<para>
Class for non-transactional, user and schema-related activities, such as
login, createuser, createtable, and so on.
</para>
</sect2>
<sect2>
  <title>Pg</title>
<para>
Objects created for every SQL login and associated with a specific
TransactionAgent. Takes incoming requests, has them
processed and responds to client.
</para>
</sect2>
<sect2>
  <title>Schema</title>
<para>
Schema class. Contains tables (fields (indices)). One schemata per domain.
Corresponds to tablespace or database on other RDBMS platforms.
</para>
</sect2>
<sect2>
  <title>SubTransaction</title>
<para>
Engine's class corresponding to Transaction. Each data manipulation activity
has a SubTransaction associated with the Transaction which requested the
activity.
</para>
</sect2>
<sect2>
  <title>Table</title>
<para>
Table class. Has Fields and Indices.
</para>
</sect2>
<sect2>
  <title>Topology</title>
<para>
Topology class has all of the actors, their types, and dynamic
configuration values. Each actor maintains a Topology object which
gives it a common view for the whole node and, as necessary, the whole
cluster.
</para>
</sect2>
<sect2>
  <title>TopologyMgr</title>
<para>
Actor which receives configuration commands over 0mq and MessagePack from <command>infinisqlmgr.py</command>. Launches all other actors, updates Topology, and
distributes configuration changes to all other actors on each node.
Facilitates dynamic reconfiguration.
</para>
</sect2>
<sect2>
  <title>Transaction</title>
<para>
Class which performs transactions. Associated with the TransactionAgent
which connected to the client that initiated the request.
</para>
</sect2>
<sect2>
  <title>TransactionAgent</title>
<para>
Actor which communicates with clients and executes transactions.
Coordinates of activities between several other actors.
</para>
</sect2>
<sect2>
  <title>UserSchemaMgr</title>
<para>
Actor which maintains user and domain authentication information and
schema definitions. There is only 1 active UserSchemaMgr per cluster.
</para>
</sect2>
<sect2>
  <title>api</title>
<para>
API for creating stored procedures. Pg objects also inherit from
this class, because they perform the same types of transactional activities
as a 0 procedure.
</para>
</sect2>
<sect2>
  <title>spooky</title>
<para>
Spooky Hash from Bob Jenkins. This is public domain.
</para>
</sect2>

</sect1>
<sect1>
  <title>Independent Source &amp; Headers</title>
<para>
  These files have no direct relationship to a corresponding source or
header file. Each entry describes a single file.
</para>

<sect2>
  <title>infinisql_defs.h</title>
<para>
  Global struct &amp; enum types, global function declarations, global
symbols in general.
</para>
</sect2>
<sect2>
  <title>infinisql_gch.h</title>
<para>  
Headers for all external dependencies. Originally so named because 
pre-compilation was applied to speed the build process (Global Precompiled Header). Stopped pre-compilation awhile back, but didn't change the filename.
</para>
</sect2>
<sect2>
  <title>larx.h</title>
<para>
  Function declarations so flex and bison can work together.
</para>
</sect2>
<sect2>
  <title>main.cc</title>
<para>
  Contains <function>main</function> and various global function definitions.
</para>
</sect2>
<sect2>
  <title>pgoids.h</title>
<para>
  Symbols necessary to implement the PostgreSQL Frontend/Backend Protocol.
<note>
<para>
  This file has the same <link xl:href="http://www.postgresql.org/about/licence/">license</link> as the PostgreSQL project, and is not
covered by the GPL. This is because the contents were lifted from PostgreSQL source.
</para>
</note>
</para>
</sect2>

</sect1>
</chapter>

</part>

</book>
